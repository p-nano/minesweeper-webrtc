<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ â€” è‡ªå‹•/æ‰‹å‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°å¯¾å¿œ</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui;padding:12px}
  .panel{border:1px solid #ccc;padding:8px;border-radius:6px;margin-bottom:10px}
  table{border-collapse:collapse;margin:0 auto}
  td{width:26px;height:26px;border:1px solid #333;text-align:center;vertical-align:middle;user-select:none;cursor:pointer;background:#fff}
  td.open{background:#e6e6e6}
  td.flag{background:#ffd6d6}
  .small{font-size:12px;padding:4px 6px;margin:2px}
  textarea{width:100%;height:100px}
  #boards{display:flex;gap:20px;flex-wrap:wrap;justify-content:center}
  @media(max-width:900px){#boards{flex-direction:column;align-items:center}}
</style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ â€” è‡ªå‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°å¯¾å¿œ</h1>

  <div class="panel">
    <strong>Signaling ã‚µãƒ¼ãƒãƒ¼ (è‡ªå‹•æ¥ç¶š)</strong><br>
    Signaling URL: <input id="signalingUrl" style="width:70%" value="https://cold-sun-7449.poppo2525s-r.workers.dev/"><br>
    Room ID: <input id="roomId" value="room1"> 
    <button id="hostAuto" class="small">ãƒ›ã‚¹ãƒˆã§è‡ªå‹•æ¥ç¶šï¼ˆä½œæˆï¼‰</button>
    <button id="joinAuto" class="small">ã‚²ã‚¹ãƒˆã§è‡ªå‹•æ¥ç¶šï¼ˆå‚åŠ ï¼‰</button>
    <button id="disconnectAuto" class="small">ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°åˆ‡æ–­</button>
    <div style="margin-top:6px;font-size:12px;color:#444">è‡ªå‹•ãŒå¤±æ•—ã—ãŸã‚‰ä¸‹ã®æ‰‹å‹•ã‚’ä½¿ã†</div>
    <div id="signalLog" style="margin-top:8px;max-height:140px;overflow:auto;border-top:1px dashed #ddd;padding-top:6px;font-size:12px"></div>
  </div>

  <div class="panel">
    <strong>æ‰‹å‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ï¼ˆç¢ºå®Ÿã«æ¥ç¶šã§ãã‚‹ç‰ˆï¼‰</strong><br>
    <div style="display:flex;gap:6px;">
      <button id="createOfferBtn" class="small">Create Offer (Host)</button>
      <button id="copyOfferBtn" class="small">Copy Offer</button>
      <button id="createAnswerBtn" class="small">Create Answer (Guest)</button>
    </div>
    <textarea id="offerArea" placeholder="Offer here"></textarea>
    <textarea id="answerArea" placeholder="Answer here"></textarea>
    <button id="applyAnswerBtn" class="small">Apply Answer</button>
  </div>

  <div class="panel">
    <strong>ã‚²ãƒ¼ãƒ  & è¨­å®š</strong><br>
    è¡Œ: <input id="rows" type="number" value="16" min="2" max="40"> 
    åˆ—: <input id="cols" type="number" value="16" min="2" max="40"> 
    åœ°é›·: <input id="mines" type="number" value="40" min="1">
    <button id="createSelf" class="small">è‡ªåˆ†ç›¤é¢ä½œæˆ</button>
    <button id="sendConfig" class="small">è¨­å®šã‚’é€ä¿¡</button>
    <label style="margin-left:8px"><input id="allowRemote" type="checkbox"> ç›¸æ‰‹ã®æ“ä½œã‚’è¨±å¯</label>
  </div>

  <div id="boards">
    <div class="panel" style="min-width:300px">
      <h3>è‡ªåˆ†ï¼ˆå·¦ï¼‰</h3>
      <div>æ™‚é–“: <span id="selfTimer">00:00</span>ã€€çŠ¶æ…‹: <span id="selfState">ã‚²ãƒ¼ãƒ ä¸­...</span></div>
      <table id="selfBoard"></table>
    </div>
    <div class="panel" style="min-width:300px">
      <h3>ç›¸æ‰‹ï¼ˆå³ï¼‰</h3>
      <div>çŠ¶æ…‹: <span id="otherState">æœªæ¥ç¶š</span></div>
      <table id="otherBoard"></table>
    </div>
  </div>

<script>
// ---------------------------------------------------------
// çœç•¥ãªã—å®Œå…¨ç‰ˆ WebRTC + Manual ICE fixed
// ---------------------------------------------------------
function el(id){return document.getElementById(id)}
let ROWS=16, COLS=16, MINES=40;
let boardSelf=[], boardOther=[];
let firstClick=true, seconds=0, timer=null;

function createEmpty(rows,cols){
  const b=[]; for(let r=0;r<rows;r++){ const row=[]; for(let c=0;c<cols;c++) row.push({mine:false,number:0,opened:false,flagged:false}); b.push(row); } return b;
}
function countAdj(b,r,c){ let n=0; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const nr=r+dr,nc=c+dc; if(nr>=0 && nr<b.length && nc>=0 && nc<b[0].length && b[nr][nc].mine) n++; } return n; }
function placeMines(b,rows,cols,mines,exR,exC){ let p=0; while(p<mines){ const r=Math.floor(Math.random()*rows), c=Math.floor(Math.random()*cols); if((r===exR && c===exC)|| b[r][c].mine) continue; b[r][c].mine=true; p++; } for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(!b[r][c].mine) b[r][c].number=countAdj(b,r,c); }
function initBoards(rows,cols,mines){ ROWS=rows;COLS=cols;MINES=mines; boardSelf=createEmpty(rows,cols); boardOther=createEmpty(rows,cols); firstClick=true; seconds=0; clearInterval(timer); el('selfTimer').textContent='00:00'; renderAll(); }
function formatTime(s){ const m=Math.floor(s/60).toString().padStart(2,'0'); const ss=(s%60).toString().padStart(2,'0'); return m+':'+ss; }

function openSelf(r,c){
  const cell=boardSelf[r][c];
  if(cell.opened||cell.flagged) return;
  cell.opened=true;
  if(cell.mine){ el('selfState').textContent='ğŸ’¥ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼'; clearInterval(timer); sendState(); return; }
  if(cell.number===0) for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const nr=r+dr,nc=c+dc; if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && !(nr===r && nc===c)) openSelf(nr,nc); }
  checkClear(); sendState();
}
function toggleFlagSelf(r,c){ const cell=boardSelf[r][c]; if(cell.opened) return; cell.flagged=!cell.flagged; renderAll(); sendState(); }
function checkClear(){ let cnt=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(!boardSelf[r][c].mine && boardSelf[r][c].opened) cnt++; if(cnt===ROWS*COLS-MINES){ el('selfState').textContent='ğŸ‰ã‚¯ãƒªã‚¢ï¼'; clearInterval(timer); } }

function renderAll(){ renderSelf(); renderOther(); }
function renderSelf(){
  const tb=el('selfBoard'); tb.innerHTML='';
  for(let r=0;r<ROWS;r++){
    const tr=document.createElement('tr');
    for(let c=0;c<COLS;c++){
      const td=document.createElement('td'); const cell=boardSelf[r][c];
      if(cell.opened){ td.classList.add('open'); td.textContent = cell.mine?'ğŸ’£':(cell.number?cell.number:''); }
      else if(cell.flagged){ td.classList.add('flag'); td.textContent='ğŸš©'; }
      td.onclick=()=>{ if(firstClick){ placeMines(boardSelf,ROWS,COLS,MINES,r,c); firstClick=false; } if(!timer) timer=setInterval(()=>{ seconds++; el('selfTimer').textContent=formatTime(seconds); },1000); openSelf(r,c); renderAll(); };
      td.oncontextmenu=e=>{ e.preventDefault(); toggleFlagSelf(r,c); };
      tr.appendChild(td);
    }
    tb.appendChild(tr);
  }
}
function renderOther(){
  const tb=el('otherBoard'); tb.innerHTML='';
  const rlen=boardOther.length, clen=rlen?boardOther[0].length:0;
  for(let r=0;r<rlen;r++){
    const tr=document.createElement('tr');
    for(let c=0;c<clen;c++){
      const td=document.createElement('td'); const cell=boardOther[r][c];
      if(cell.opened){ td.classList.add('open'); td.textContent = cell.number?cell.number:''; }
      else if(cell.flagged){ td.classList.add('flag'); td.textContent='ğŸš©'; }
      tr.appendChild(td);
    }
    tb.appendChild(tr);
  }
}

// ---------------- WebRTC æ ¸å¿ƒï¼ˆã“ã“ãŒä¿®æ­£ç‰ˆï¼‰ ----------------
let pc=null, dataChannel=null, localCandidates=[];

async function createPeer(){
  pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  localCandidates=[];
  pc.onicecandidate = e=>{
    if(e.candidate) localCandidates.push(e.candidate);
  };
  pc.ondatachannel = e=>{ dataChannel=e.channel; setupDataChannel(); };
  return pc;
}
function setupDataChannel(){
  if(!dataChannel) return;
  dataChannel.onopen = ()=>{ sendState(); el('otherState').textContent='æ¥ç¶šä¸­'; };
  dataChannel.onmessage = e=>{ try{ handleRemoteData(JSON.parse(e.data)); }catch(err){console.error(err);} };
}
function waitGather(){ return new Promise(r=>{ if(pc.iceGatheringState==="complete") r(); pc.onicegatheringstatechange=()=>pc.iceGatheringState==="complete"&&r(); setTimeout(r,3000); }); }
async function applyCandidates(list){ if(!list) return; for(const c of list) try{ await pc.addIceCandidate(c);}catch{} }

function sendData(o){ if(dataChannel&&dataChannel.readyState==="open") dataChannel.send(JSON.stringify(o)); }

// state sync
function handleRemoteData(msg){
  if(msg.type==='state') applyRemoteState(msg);
}
function applyRemoteState(msg){
  boardOther=createEmpty(msg.config.rows,msg.config.cols);
  msg.opened.forEach(o=>{ boardOther[o.r][o.c].opened=true; boardOther[o.r][o.c].number=o.number; });
  msg.flagged.forEach(f=>{ boardOther[f.r][f.c].flagged=true; });
  el('otherState').textContent=msg.status;
  renderOther();
}
function buildState(){ const opened=[],flagged=[]; for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++){ const t=boardSelf[r][c]; if(t.opened) opened.push({r,c,number:t.number}); if(t.flagged) flagged.push({r,c,flagged:true}); } return {type:'state',opened,flagged,config:{rows:ROWS,cols:COLS,mines:MINES},status:el('selfState').textContent}; }
function sendState(){ sendData(buildState()); }

// ---------------- æ‰‹å‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚° å®Œå…¨ç‰ˆ ----------------
el('createOfferBtn').onclick = async ()=>{
  await createPeer();
  dataChannel = pc.createDataChannel("ms"); setupDataChannel();
  await pc.setLocalDescription(await pc.createOffer());
  await waitGather();
  el('offerArea').value = JSON.stringify({sdp:pc.localDescription,candidates:localCandidates});
};
el('copyOfferBtn').onclick=()=>navigator.clipboard.writeText(el('offerArea').value);
el('createAnswerBtn').onclick = async ()=>{
  const o=JSON.parse(el('offerArea').value.trim()); await createPeer();
  await pc.setRemoteDescription(new RTCSessionDescription(o.sdp));
  await applyCandidates(o.candidates);
  await pc.setLocalDescription(await pc.createAnswer());
  await waitGather();
  el('answerArea').value=JSON.stringify({sdp:pc.localDescription,candidates:localCandidates});
};
el('applyAnswerBtn').onclick = async ()=>{
  const o=JSON.parse(el('answerArea').value.trim());
  await pc.setRemoteDescription(new RTCSessionDescription(o.sdp));
  await applyCandidates(o.candidates);
  alert("âœ… Answer applied â€” æ¥ç¶šã‚’å¾…æ©Ÿä¸­");
};

// ---------------- WebSocketï¼ˆè‡ªå‹•ï¼‰éƒ¨åˆ†ã¯å¤‰æ›´ãªã— ----------------
let ws=null, curRoom='', myRole='host';
function wsUrlFromInput(){
  let url=el('signalingUrl').value.trim();
  try{ let u=new URL(url); if(u.protocol==='http:')u.protocol='ws:'; if(u.protocol==='https:')u.protocol='wss:'; return u.toString(); }
  catch(e){return url;}
}
function logSignal(t){ el('signalLog').prepend(Object.assign(document.createElement('div'),{textContent:t})); }
function wsSend(o){ if(ws&&ws.readyState===1) ws.send(JSON.stringify(o)); }

async function wsConnect(role,room){
  myRole=role; curRoom=room||"room1"; ws=new WebSocket(wsUrlFromInput());
  ws.onopen=()=>wsSend({type:'join',room:curRoom,role});
  ws.onmessage=async e=>{
    const m=JSON.parse(e.data);
    if(m.type==='join'&&role==='host'){ await createPeer(); dataChannel=pc.createDataChannel("ms"); setupDataChannel(); await pc.setLocalDescription(await pc.createOffer()); wsSend({type:'offer',room:curRoom,sdp:pc.localDescription}); }
    if(m.type==='offer'&&role==='guest'){ await createPeer(); await pc.setRemoteDescription(m.sdp); await pc.setLocalDescription(await pc.createAnswer()); wsSend({type:'answer',room:curRoom,sdp:pc.localDescription}); }
    if(m.type==='answer'&&role==='host'){ await pc.setRemoteDescription(m.sdp); }
    if(m.type==='candidate'){ try{ await pc.addIceCandidate(m.candidate);}catch{} }
  };
}
el('hostAuto').onclick=()=>wsConnect('host',el('roomId').value);
el('joinAuto').onclick=()=>wsConnect('guest',el('roomId').value);
el('disconnectAuto').onclick=()=>{ ws&&ws.close(); pc&&pc.close(); };

el('createSelf').onclick=()=> initBoards(+el('rows').value,+el('cols').value,+el('mines').value);
el('sendConfig').onclick=()=> sendState();

initBoards(ROWS,COLS,MINES);
</script>
</body>
</html>
