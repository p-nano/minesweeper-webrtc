<!DOCTYPE html>
<html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>JSFiddle akhoy4mL</title>

  <style>
    
  </style>

  
</head>
<body>
  <!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ â€” è‡ªå‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°å¯¾å¿œï¼ˆWebSocketï¼‰</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:system-ui;padding:12px}
  .panel{border:1px solid #ccc;padding:8px;border-radius:6px;margin-bottom:10px}
  table{border-collapse:collapse;margin:0 auto}
  td{width:26px;height:26px;border:1px solid #333;text-align:center;vertical-align:middle;user-select:none;cursor:pointer;background:#fff}
  td.open{background:#e6e6e6}
  td.flag{background:#ffd6d6}
  .small{font-size:12px;padding:4px 6px;margin:2px}
  textarea{width:100%;height:100px}
  #boards{display:flex;gap:20px;flex-wrap:wrap;justify-content:center}
  @media(max-width:900px){#boards{flex-direction:column;align-items:center}}
</style>
</head>
<body>
  <h1>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ â€” è‡ªå‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°å¯¾å¿œ</h1>

  <div class="panel">
    <strong>Signaling ã‚µãƒ¼ãƒãƒ¼ (è‡ªå‹•æ¥ç¶š)</strong><br>
    Signaling URL: <input id="signalingUrl" style="width:70%" value="https://cold-sun-7449.poppo2525s-r.workers.dev/"><br>
    Room ID: <input id="roomId" value="room1"> 
    <button id="hostAuto" class="small">ãƒ›ã‚¹ãƒˆã§è‡ªå‹•æ¥ç¶šï¼ˆä½œæˆï¼‰</button>
    <button id="joinAuto" class="small">ã‚²ã‚¹ãƒˆã§è‡ªå‹•æ¥ç¶šï¼ˆå‚åŠ ï¼‰</button>
    <button id="disconnectAuto" class="small">ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°åˆ‡æ–­</button>
    <div style="margin-top:6px;font-size:12px;color:#444">â€» è‡ªå‹•æ¥ç¶šãŒå¤±æ•—ã—ãŸå ´åˆã¯ä¸‹ã®ã€Œæ‰‹å‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã€æ¬„ã§ã‚³ãƒ”ãƒ¼/è²¼ä»˜ã‘ã‚’ä½¿ã£ã¦ä¸‹ã•ã„ã€‚</div>
    <div id="signalLog" style="margin-top:8px;max-height:140px;overflow:auto;border-top:1px dashed #ddd;padding-top:6px;font-size:12px"></div>
  </div>

  <div class="panel">
    <strong>æ‰‹å‹•ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ï¼ˆå¾“æ¥ã®ã‚³ãƒ”ãƒšã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰</strong><br>
    <div style="display:flex;gap:6px;">
      <button id="createOfferBtn" class="small">Create Offer (Manual)</button>
      <button id="copyOfferBtn" class="small">Copy Offer</button>
      <button id="createAnswerBtn" class="small">Create Answer (Guest)</button>
    </div>
    <textarea id="offerArea" placeholder="Offer appears here (manual)"></textarea>
    <textarea id="answerArea" placeholder="Paste Answer here and Apply"></textarea>
    <div style="margin-top:6px">
      <button id="applyAnswerBtn" class="small">Apply Answer</button>
    </div>
  </div>

  <div class="panel">
    <strong>ã‚²ãƒ¼ãƒ  & è¨­å®š</strong><br>
    è¡Œ: <input id="rows" type="number" value="16" min="2" max="40"> 
    åˆ—: <input id="cols" type="number" value="16" min="2" max="40"> 
    åœ°é›·: <input id="mines" type="number" value="40" min="1">
    <button id="createSelf" class="small">è‡ªåˆ†ç›¤é¢ä½œæˆ</button>
    <button id="sendConfig" class="small">è¨­å®šã‚’é€ä¿¡</button>
    <label style="margin-left:8px"><input id="showHint"> ãƒ’ãƒ³ãƒˆè¡¨ç¤º</label>
    <label style="margin-left:8px"><input id="allowRemote" type="checkbox"> ç›¸æ‰‹ã«è‡ªåˆ†ã¸ã®é éš”æ“ä½œã‚’è¨±å¯</label>
  </div>

  <div id="boards">
    <div class="panel" style="min-width:300px">
      <h3>è‡ªåˆ†ï¼ˆå·¦ï¼‰</h3>
      <div>æ™‚é–“: <span id="selfTimer">00:00</span>ã€€çŠ¶æ…‹: <span id="selfState">ã‚²ãƒ¼ãƒ ä¸­...</span></div>
      <div id="selfBoardWrap"><table id="selfBoard"></table></div>
    </div>
    <div class="panel" style="min-width:300px">
      <h3>ç›¸æ‰‹ï¼ˆå³ï¼‰</h3>
      <div>çŠ¶æ…‹: <span id="otherState">æœªæ¥ç¶š</span></div>
      <div id="otherBoardWrap"><table id="otherBoard"></table></div>
    </div>
  </div>

<script>
function el(id){return document.getElementById(id)}
let ROWS=16, COLS=16, MINES=40;
let boardSelf=[], boardOther=[];
let firstClick=true, seconds=0, timer=null;

function createEmpty(rows,cols){
  const b=[]; for(let r=0;r<rows;r++){ const row=[]; for(let c=0;c<cols;c++) row.push({mine:false,number:0,opened:false,flagged:false}); b.push(row); } return b;
}
function countAdj(b,r,c){ let n=0; for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const nr=r+dr,nc=c+dc; if(nr>=0 && nr<b.length && nc>=0 && nc<b[0].length && b[nr][nc].mine) n++; } return n; }
function placeMines(b,rows,cols,mines,exR,exC){ let p=0; while(p<mines){ const r=Math.floor(Math.random()*rows), c=Math.floor(Math.random()*cols); if((r===exR && c===exC)|| b[r][c].mine) continue; b[r][c].mine=true; p++; } for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(!b[r][c].mine) b[r][c].number=countAdj(b,r,c); }
function initBoards(rows,cols,mines){ ROWS=rows;COLS=cols;MINES=mines; boardSelf=createEmpty(rows,cols); boardOther=createEmpty(rows,cols); firstClick=true; seconds=0; clearInterval(timer); el('selfTimer').textContent='00:00'; renderAll(); }
function formatTime(s){ const m=Math.floor(s/60).toString().padStart(2,'0'); const ss=(s%60).toString().padStart(2,'0'); return m+':'+ss; }

function openSelf(r,c){
  const cell=boardSelf[r][c];
  if(cell.opened||cell.flagged) return;
  cell.opened=true;
  if(cell.mine){ el('selfState').textContent='ğŸ’¥ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼'; clearInterval(timer); sendState(); return; }
  if(cell.number===0) for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ const nr=r+dr,nc=c+dc; if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS && !(nr===r && nc===c)) openSelf(nr,nc); }
  checkClear(); sendState();
}
function toggleFlagSelf(r,c){ const cell=boardSelf[r][c]; if(cell.opened) return; cell.flagged=!cell.flagged; renderAll(); sendState(); }
function checkClear(){ let cnt=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(!boardSelf[r][c].mine && boardSelf[r][c].opened) cnt++; if(cnt===ROWS*COLS-MINES){ el('selfState').textContent='ğŸ‰ã‚¯ãƒªã‚¢ï¼'; clearInterval(timer); } }

function renderAll(){ renderSelf(); renderOther(); }
function renderSelf(){
  const tb=el('selfBoard'); tb.innerHTML=''; for(let r=0;r<ROWS;r++){ const tr=document.createElement('tr'); for(let c=0;c<COLS;c++){ const td=document.createElement('td'); const cell=boardSelf[r][c]; if(cell.opened){ td.classList.add('open'); td.textContent = cell.mine ? 'ğŸ’£' : (cell.number?cell.number:''); } else if(cell.flagged){ td.classList.add('flag'); td.textContent='ğŸš©'; } td.addEventListener('click', ()=>{ if(firstClick){ placeMines(boardSelf,ROWS,COLS,MINES,r,c); firstClick=false; } if(!timer) timer=setInterval(()=>{ seconds++; el('selfTimer').textContent=formatTime(seconds); },1000); openSelf(r,c); renderAll(); }); td.addEventListener('contextmenu', e=>{ e.preventDefault(); toggleFlagSelf(r,c); }); tr.appendChild(td); } tb.appendChild(tr); } }
function renderOther(){ const tb=el('otherBoard'); tb.innerHTML=''; const rlen=boardOther.length; const clen=rlen?boardOther[0].length:0; for(let r=0;r<rlen;r++){ const tr=document.createElement('tr'); for(let c=0;c<clen;c++){ const td=document.createElement('td'); const cell=boardOther[r][c]||{opened:false,flagged:false,number:0}; if(cell.opened){ td.classList.add('open'); td.textContent = cell.number?cell.number:''; } else if(cell.flagged){ td.classList.add('flag'); td.textContent='ğŸš©'; } td.addEventListener('click', ()=>{ if(dataChannel && dataChannel.readyState==='open'){ sendDataChannel({type:'requestOpen',r,c}); } else if(ws && ws.readyState==='open'){ wsSend({type:'requestOpen',r,c,room:curRoom}); } else { console.warn('not connected'); } }); tr.appendChild(td); } tb.appendChild(tr); } }

///// WebRTC core /////
let pc=null, dataChannel=null;

async function createPeer(){
  pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
  pc.onicecandidate = e => { if(e.candidate) signalSend({type:'candidate',candidate:e.candidate,room:curRoom}); };
  pc.ondatachannel = e => { dataChannel = e.channel; setupDataChannel(); };
  pc.onconnectionstatechange = ()=> console.log('pc state', pc.connectionState);
  return pc;
}

function setupDataChannel(){
  if(!dataChannel) return;
  dataChannel.onopen = ()=>{ logSignal('DataChannel OPEN'); sendDataChannel({type:'hello',role:myRole}); sendState(); };
  dataChannel.onclose = ()=>{ logSignal('DataChannel CLOSED'); };
  dataChannel.onmessage = e=>{ try{ const m=JSON.parse(e.data); handleRemoteData(m); }catch(err){console.error(err);} };
}

function sendDataChannel(obj){ if(dataChannel && dataChannel.readyState==='open') dataChannel.send(JSON.stringify(obj)); }

function handleRemoteData(msg){
  if(!msg || !msg.type) return;
  if(msg.type==='state'){ applyRemoteState(msg); }
  else if(msg.type==='requestOpen'){ 
    if(el('allowRemote').checked){
      if(firstClick){ placeMines(boardSelf,ROWS,COLS,MINES,msg.r,msg.c); firstClick=false; }
      openSelf(msg.r,msg.c); renderAll(); sendState();
    }
  }
}

function applyRemoteState(msg){
  if(msg.config){ boardOther = createEmpty(msg.config.rows,msg.config.cols); } 
  if(msg.opened) msg.opened.forEach(o=>{ if(boardOther[o.r] && boardOther[o.r][o.c]){ boardOther[o.r][o.c].opened=true; boardOther[o.r][o.c].number=o.number; boardOther[o.r][o.c].flagged=false; } });
  if(msg.flagged) msg.flagged.forEach(f=>{ if(boardOther[f.r] && boardOther[f.r][f.c]){ boardOther[f.r][f.c].flagged=!!f.flagged; if(f.flagged) boardOther[f.r][f.c].opened=false; } });
  if(msg.status) el('otherState').textContent = msg.status;
  renderOther();
}

function buildStatePayload(){
  const opened=[], flagged=[];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ const cell=boardSelf[r][c]; if(cell.opened) opened.push({r,c,number:cell.number}); if(cell.flagged) flagged.push({r,c,flagged:true}); }
  return {type:'state',opened,flagged,config:{rows:ROWS,cols:COLS,mines:MINES},status:el('selfState').textContent};
}

function sendState(){ const p=buildStatePayload(); if(dataChannel && dataChannel.readyState==='open') sendDataChannel(p); else if(ws && ws.readyState==='open') wsSend(Object.assign({},p,{room:curRoom})); }

/* ----- manual signaling ----- */
el('createOfferBtn').addEventListener('click', async ()=>{
  await createPeer();
  dataChannel = pc.createDataChannel('ms'); setupDataChannel();
  const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
  el('offerArea').value = JSON.stringify({sdp:pc.localDescription});
});
el('copyOfferBtn').addEventListener('click', ()=> navigator.clipboard.writeText(el('offerArea').value).then(()=>alert('Offer copied')));
el('createAnswerBtn').addEventListener('click', async ()=>{
  const raw=el('offerArea').value.trim(); if(!raw){ alert('Paste Offer to offer area first'); return; }
  const obj=JSON.parse(raw);
  await createPeer();
  await pc.setRemoteDescription(new RTCSessionDescription(obj.sdp));
  const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
  el('answerArea').value = JSON.stringify({sdp:pc.localDescription});
});
el('applyAnswerBtn').addEventListener('click', async ()=>{ const raw=el('answerArea').value.trim(); if(!raw){alert('Paste Answer');return;} const obj=JSON.parse(raw); if(!pc) await createPeer(); await pc.setRemoteDescription(new RTCSessionDescription(obj.sdp)); alert('Answer applied'); });

/* ====== WebSocket signaling ====== */
let ws=null; let curRoom=''; let myRole='host';
function wsUrlFromInput(){
  let url = el('signalingUrl').value.trim();
  if(!url) return null;
  try{
    const u = new URL(url);
    if(u.protocol === 'http:') u.protocol = 'ws:';
    else if(u.protocol === 'https:') u.protocol = 'wss:';
    return u.toString();
  }catch(e){
    if(url.startsWith('ws://')||url.startsWith('wss://')) return url;
    return null;
  }
}
function logSignal(text){ const d=el('signalLog'); const p=document.createElement('div'); p.textContent=(new Date()).toLocaleTimeString()+' '+text; d.prepend(p); }

async function wsConnect(asRole,room){
  const wurl = wsUrlFromInput(); if(!wurl){ alert('Signaling URL ã‚’ç¢ºèªã—ã¦ä¸‹ã•ã„'); return; }
  myRole = asRole; curRoom = room || el('roomId').value || 'room1';
  try{ ws = new WebSocket(wurl); }catch(e){ alert('WebSocketæ¥ç¶šã«å¤±æ•—: '+e.message); return; }
  ws.onopen = ()=>{ logSignal('WS connected'); wsSend({type:'join',room:curRoom,role:myRole}); el('otherState').textContent='æ¥ç¶šä¸­...'; };
  ws.onmessage = async e=>{
    try{ const msg = JSON.parse(e.data); logSignal('recv: '+(msg.type||'-')); await handleSignalMessage(msg); }catch(err){ console.error(err); }
  };
  ws.onclose = ()=>{ logSignal('WS closed'); el('otherState').textContent='åˆ‡æ–­'; };
  ws.onerror = (ev)=>{ console.error(ev); logSignal('WS error'); };
}
function wsSend(obj){ if(ws && ws.readyState==='open'){ ws.send(JSON.stringify(obj)); logSignal('send: '+(obj.type||'obj')); } }

async function handleSignalMessage(msg){
  if(!msg.type) return;
  if(msg.type==='offer' && myRole==='guest' && msg.room===curRoom){
    await createPeer();
    await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    wsSend({type:'answer',room:curRoom,sdp:pc.localDescription});
    logSignal('sent answer via WS');
  } else if(msg.type==='answer' && myRole==='host' && msg.room===curRoom){
    if(!pc) await createPeer();
    await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
    logSignal('Answer applied (host)');
  } else if(msg.type==='candidate' && msg.room===curRoom){
    if(pc) try{ await pc.addIceCandidate(msg.candidate); }catch(e){ console.warn('addIce failed',e); }
  } else if(msg.type==='join' && myRole==='host' && msg.room===curRoom){
    if(!pc) await createPeer();
    dataChannel = pc.createDataChannel('ms'); setupDataChannel();
    const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
    wsSend({type:'offer',room:curRoom,sdp:pc.localDescription});
    logSignal('Sent offer (auto)');
  }
}

el('hostAuto').addEventListener('click', ()=> wsConnect('host', el('roomId').value));
el('joinAuto').addEventListener('click', ()=> wsConnect('guest', el('roomId').value));
el('disconnectAuto').addEventListener('click', ()=>{ if(ws) ws.close(); if(pc) pc.close(); });

el('createSelf').addEventListener('click', ()=> initBoards(+el('rows').value,+el('cols').value,+el('mines').value));
el('sendConfig').addEventListener('click', ()=> sendState());

initBoards(ROWS,COLS,MINES);
</script>
</body>
</html>

  <script>
    
  </script>
</body>
</html>
